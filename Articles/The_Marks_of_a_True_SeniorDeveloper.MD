# The Marks of a True Senior Developer And how to spot them in the wild


There is a wide range in the skill of developers out there — and seniority often doesn’t determine one's caliber. So what makes some superior to their peers? What is it that separates them from the pack and sea of mediocrity?
Having five, ten or even fifteen years of ‘work experience’ doesn’t necessarily guarantee that you’re an effective, efficient senior developer — or even deserving of the title. There are certainly poor ones out there who give successful seniors, who are often older in age, a bad rep. Young seniors don’t have it any easier either — but there are certain traits and knowledge that are shared among the echelons of senior developers.
It’s not a trade secret, but rather a recipe of knowledge points and ways of thinking that can be developed. Here are some of the traits that easily help distinguish between a true senior developer and a developer with seniority.

### Programming Paradigms
SOLID, Object-Oriented, and Functional Programming are a trio of programming paradigms and clean coding techniques which make up a good portion of the modes of thinking behind code creation.
What a lot of junior developers miss on their coding journey is that programming is a language — which means that it extends beyond grammatical rules. It’s a communication tool that can be structured in multiple ways and programming paradigms help create a certain stance on the way your code is communicated.
Anyone can write code — just as anyone can write a text message or a short book review on Amazon. But that sort of writing is not at the same level as a Stephen King novel. Programming paradigms act as the guiding force behind a senior developer’s code as much as plot structures do for fiction writers. All languages are made up of formulas and senior developers understand them at an internalized level that many junior and intermediate developers have yet to experience.

### Ability to Create
When we first start out in the world of for loops and if else statements, we tend to find answers in the form of ready for copy and paste code. How they comprehend it differentiates the skill of new juniors and low-level intermediate developers.
Seniors, however, take it one step further. They are able to create like mini-gods in their sandboxes without much assistance from the almighty knowledge bank of Google. They know what they’re doing and they understand the implications of their moves. They see the contingencies, or at least anticipate them, and understand the potholes in their code and how to improve it.
If there is a gap in their knowledge, they look further than just the surface. There is a deeper understanding of everything in the toolbox. The world of code looks differently for senior developers.

### Objective Criticism
Everyone is biased towards why they know. Junior and intermediate developers tend to display their extreme biases based on personal experiences rather than code related reasoning. Their personal preferences, styles, naming conventions, and methods of thinking become the centerpiece of any suggestion or evaluation they may encounter.
There’s nothing wrong with that, as it’s all part of the process of growing up. True objectivity is not obtained until there is enough of a range of opposing experiences to provide a centering effect on the developer. There is no right way to code, only efficient ways based on situations and scenarios. The senior developer understands this. They accept that their code may not be the best and that there is space for improvement.
Senior developers often become effective code janitors, marking messes made by their peers and labeling the weak parts in the architecture. They are able to step back and see a much bigger picture with future contingencies while making choices based on the least expected negative impact. They are not bound to any one style of coding or paradigm — instead, focusing on the solution rather than the tool.

### The Distinction Between Good Software and Working Software
As developers, we make code that runs. Some of us stop there and call it a day. Others take it a bit further and try to clean things up. The best developers are such pros that they edit and rewrite our code as they’re coding — accepting the blips and failures as they go, only to improve it as soon as they can because they know the difference between good software and working software.
Most bosses focus only on whether the software is working, but the good senior developer knows better. They understand the hidden costs of technical debt and code smells. They understand how to balance the demands of working software with good software — to walk the fine line of on-time project delivery and extension negotiations.
Their breadth of knowledge and understanding of frameworks and languages makes them experts at telling the difference between good and working software — and how to create both — and gives them the ability to come up with creative solutions when the situation demands it.

### Ability to Teach
“The mediocre teacher tells. The good teacher explains. The superior teacher demonstrates. The great teacher inspires.” — William Arthur Ward
True senior developers have a certain passion about them that inspires their less experienced peers in their field, helping polish the next generation of diamonds.
Programming itself is a collection of ideas and seniors have the ability to translate these into something that is succinct and easily digestible. Their ability to communicate and translate code between different interfaces and mediums demonstrate their true understanding of the language they’ve chosen to master.
There is a level of mastery required to become a teacher of anything. While ‘experience’ may come in the form of projects on their resumes and length of time at different companies, teaching is a skill that is only available to those that truly understand their craft.

### Final Words
The true senior developer is a multi-faceted creature that some times masquerades linguistically as a junior or intermediate developer in areas outside their main toolkit but has a strong foundation in programming philosophies.
However, the traits above are present in their personality and depth of knowledge. It gives them the advantage of traversing through unknown territories of code faster than the average programmer. They are often big picture thinkers and view code with an enlightened mindset.
They will advocate for clean coding habits and guide their peers towards it without being a bias force of destruction. They are kind to their peers’ mistakes and accept their own ones with grace — aiming to educate and learn rather than destroy egos.
They can be any age, come from any background, and hold any number of years of ‘experience’. They are true problem solvers and long term thinkers. Do you have what it takes?
